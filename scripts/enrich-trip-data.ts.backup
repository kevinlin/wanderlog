#!/usr/bin/env tsx
/**
 * Comprehensive enrichment script to populate trip data with:
 *   - thumbnail_url: Images for places
 *   - google_place_id: Google Places IDs
 *   - activity_type: Activity type classification
 * Comprehensive enrichment script to populate trip data with:
 *   - thumbnail_url: Images for places
 *   - google_place_id: Google Places IDs
 *   - activity_type: Activity type classification
 *
 * Usage:
 *   pnpm tsx scripts/enrich-trip-data.ts [filename]
 *
 * Examples:
 *   pnpm tsx scripts/enrich-trip-data.ts                              # Enrich all trips
 *   pnpm tsx scripts/enrich-trip-data.ts 202512_NZ_trip-plan.json    # Enrich specific trip
 *
 * Image source priority:
 *   1. Existing thumbnail_url (skip if already set)
 *   2. Google Places API photo
 *   3. Web search from place URL (og:image)
 *   4. Web search based on place name
 *
 * Activity type inference:
 *   1. Existing activity_type (preserved)
 *   2. Google Places API types ‚Üí inferred type
 *   3. Activity name keywords ‚Üí inferred type
 *
 * Activity type inference:
 *   1. Existing activity_type (preserved)
 *   2. Google Places API types ‚Üí inferred type
 *   3. Activity name keywords ‚Üí inferred type
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { fileURLToPath } from 'url';
import type { Accommodation, Activity, TripData } from '../src/types';
import type { ScenicWaypoint } from '../src/types/map';

// Get __dirname equivalent in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ActivityType enum (standalone to avoid @/types path alias issues in Node.js)
const ActivityType = {
  RESTAURANT: 'restaurant',
  ATTRACTION: 'attraction',
  SHOPPING: 'shopping',
  OUTDOOR: 'outdoor',
  CULTURAL: 'cultural',
  RECREATION: 'recreation',
  SCENIC: 'scenic',
  BEACH: 'beach',
  PLAYGROUND: 'playground',
  GROCERY: 'grocery',
  TRANSPORT: 'transport',
  OTHER: 'other',
} as const;

type ActivityType = (typeof ActivityType)[keyof typeof ActivityType];

// Keywords for inferring activity types from activity names
const ACTIVITY_TYPE_KEYWORDS: Record<ActivityType, string[]> = {
  [ActivityType.RESTAURANT]: [
    'restaurant',
    'cafe',
    'bar',
    'pub',
    'bistro',
    'brewery',
    'winery',
    'dining',
    'food',
    'meal',
    'breakfast',
    'lunch',
    'dinner',
    'eat',
    'drink',
    'coffee',
    'bakery',
    'deli',
    'pizzeria',
    'buffet',
    'kitchen',
    'grill',
    'tavern',
  ],
  [ActivityType.ATTRACTION]: [
    'museum',
    'gallery',
    'park',
    'garden',
    'zoo',
    'aquarium',
    'attraction',
    'monument',
    'landmark',
    'sightseeing',
    'tourist',
    'visit',
    'tour',
    'observatory',
    'heritage',
    'historic',
    'castle',
    'palace',
    'cathedral',
    'church',
    'temple',
    'bridge',
    'tower',
    'falls',
    'waterfall',
    'sound',
    'fiord',
    'milford',
    'head',
    'cape',
    'point',
  ],
  [ActivityType.SHOPPING]: [
    'shop',
    'shopping',
    'market visit',
    'store',
    'mall',
    'boutique',
    'outlet',
    'souvenir',
    'craft store',
    'artisan shop',
    'farmers market',
    'buy',
    'purchase',
    'retail',
    'shopping centre',
    'shopping plaza',
  ],
  [ActivityType.OUTDOOR]: [
    'hiking',
    'walk',
    'trail',
    'track',
    'climb',
    'climbing',
    'kayak',
    'rafting',
    'fishing',
    'swimming',
    'surf',
    'bike',
    'cycling',
    'mountain',
    'alpine',
    'glacier',
    'fjord',
    'adventure',
    'outdoor',
    'nature',
    'wildlife',
    'safari',
    'bungee',
    'skydive',
    'zip',
    'jetboat',
    'cruise',
    'sailing',
    'boat trip',
    'whale watching',
    'dolphin',
    'seal',
    'penguin',
    'bird watching',
  ],
  [ActivityType.CULTURAL]: [
    'cultural',
    'culture',
    'maori',
    'indigenous',
    'traditional',
    'performance',
    'show',
    'theatre',
    'concert',
    'festival',
    'event',
    'art exhibition',
    'music',
    'dance',
    'workshop',
    'cultural experience',
    'cultural village',
    'community',
    'hangi',
    'cultural centre',
  ],
  [ActivityType.TRANSPORT]: [
    'drive',
    'driving',
    'flight',
    'ferry',
    'bus',
    'train',
    'transfer',
    'pickup',
    'drop off',
    'rental',
    'car hire',
    'airport',
    'station',
    'terminal',
    'departure',
    'arrival',
    'journey',
    'travel',
    'scenic drive',
    'route',
    'highway',
    'road',
  ],
  [ActivityType.RECREATION]: [
    'springs',
    'hot pools',
    'gondola',
    'luge',
    'jet',
    'jetboat',
    'cruise',
    'farm tour',
    'animal experience',
    'wildlife',
    'glowworm',
    'caves',
    'puzzling',
    'maze',
  ],
  [ActivityType.SCENIC]: [
    'lookout',
    'viewpoint',
    'view point',
    'summit',
    'bridge walkway',
    'scenic reserve',
    'pass',
    'mirror',
    'lake views',
  ],
  [ActivityType.BEACH]: ['beach', 'pier', 'coastline', 'bay', 'foreshore'],
  [ActivityType.PLAYGROUND]: ['playground', 'play area', 'dinosaur park', 'family playground', 'lakefront playground'],
  [ActivityType.GROCERY]: ['woolworths', 'supermarket', 'grocery', 'food market'],
  [ActivityType.OTHER]: [],
};

/**
 * Infers activity type from Google Places API types
 */
function inferActivityTypeFromGooglePlaces(placeTypes: string[]): ActivityType {
  const googlePlaceTypeMap: Record<string, ActivityType> = {
    // Restaurant types
    restaurant: ActivityType.RESTAURANT,
    food: ActivityType.RESTAURANT,
    meal_takeaway: ActivityType.RESTAURANT,
    meal_delivery: ActivityType.RESTAURANT,
    cafe: ActivityType.RESTAURANT,
    bar: ActivityType.RESTAURANT,
    bakery: ActivityType.RESTAURANT,
    night_club: ActivityType.RESTAURANT,

    // Grocery types (more specific than general shopping)
    supermarket: ActivityType.GROCERY,
    grocery_or_supermarket: ActivityType.GROCERY,
    convenience_store: ActivityType.GROCERY,

    // Playground types
    playground: ActivityType.PLAYGROUND,

    // Beach types
    beach: ActivityType.BEACH,

    // Recreation types
    amusement_park: ActivityType.RECREATION,
    aquarium: ActivityType.RECREATION,
    zoo: ActivityType.RECREATION,
    spa: ActivityType.RECREATION,
    bowling_alley: ActivityType.RECREATION,

    // Scenic types (viewpoints and natural landmarks)
    natural_feature: ActivityType.SCENIC,
    point_of_interest: ActivityType.SCENIC,

    // Attraction types
    tourist_attraction: ActivityType.ATTRACTION,
    museum: ActivityType.ATTRACTION,
    art_gallery: ActivityType.ATTRACTION,
    park: ActivityType.ATTRACTION,
    landmark: ActivityType.ATTRACTION,

    // Shopping types
    shopping_mall: ActivityType.SHOPPING,
    store: ActivityType.SHOPPING,
    clothing_store: ActivityType.SHOPPING,
    shoe_store: ActivityType.SHOPPING,
    jewelry_store: ActivityType.SHOPPING,
    book_store: ActivityType.SHOPPING,
    electronics_store: ActivityType.SHOPPING,
    furniture_store: ActivityType.SHOPPING,
    department_store: ActivityType.SHOPPING,

    // Outdoor types
    campground: ActivityType.OUTDOOR,
    rv_park: ActivityType.OUTDOOR,
    stadium: ActivityType.OUTDOOR,
    gym: ActivityType.OUTDOOR,

    // Cultural types
    library: ActivityType.CULTURAL,
    university: ActivityType.CULTURAL,
    school: ActivityType.CULTURAL,
    church: ActivityType.CULTURAL,
    hindu_temple: ActivityType.CULTURAL,
    mosque: ActivityType.CULTURAL,
    synagogue: ActivityType.CULTURAL,
    place_of_worship: ActivityType.CULTURAL,

    // Transport types
    airport: ActivityType.TRANSPORT,
    bus_station: ActivityType.TRANSPORT,
    train_station: ActivityType.TRANSPORT,
    transit_station: ActivityType.TRANSPORT,
    car_rental: ActivityType.TRANSPORT,
  };

  // Check each place type and return the first match
  for (const placeType of placeTypes) {
    const activityType = googlePlaceTypeMap[placeType];
    if (activityType) {
      return activityType;
    }
  }

  return ActivityType.OTHER;
}

/**
 * Infers activity type from activity name using keyword matching
 */
function inferActivityType(activityName: string, existingType?: ActivityType, googlePlaceTypes?: string[]): ActivityType {
  // If activity already has a type, use it
  if (existingType && Object.values(ActivityType).includes(existingType)) {
    return existingType;
  }

  // If Google Places types are provided, use them for inference
  if (googlePlaceTypes && googlePlaceTypes.length > 0) {
    const inferredFromPlaces = inferActivityTypeFromGooglePlaces(googlePlaceTypes);
    if (inferredFromPlaces !== ActivityType.OTHER) {
      return inferredFromPlaces;
    }
  }

  // Convert activity name to lowercase for case-insensitive matching
  const nameToCheck = activityName.toLowerCase();

  // Check each activity type's keywords in priority order
  // Order matters: more specific types should be checked first
  const typeOrder = [
    ActivityType.GROCERY, // Very specific keywords
    ActivityType.PLAYGROUND, // Very specific keywords
    ActivityType.RESTAURANT, // Check before BEACH to avoid false matches on "wharf" etc
    ActivityType.BEACH, // Specific location type
    ActivityType.RECREATION, // Specific activity type
    ActivityType.SCENIC, // Specific viewpoint type
    ActivityType.SHOPPING,
    ActivityType.OUTDOOR,
    ActivityType.CULTURAL,
    ActivityType.TRANSPORT,
    ActivityType.ATTRACTION, // Last because it has generic words like "visit"
  ];

  for (const activityType of typeOrder) {
    const keywords = ACTIVITY_TYPE_KEYWORDS[activityType];
    for (const keyword of keywords) {
      if (nameToCheck.includes(keyword.toLowerCase())) {
        return activityType;
      }
    }
  }

  return ActivityType.OTHER;
}

// ActivityType enum (standalone to avoid @/types path alias issues in Node.js)
const ActivityType = {
  RESTAURANT: 'restaurant',
  ATTRACTION: 'attraction',
  SHOPPING: 'shopping',
  OUTDOOR: 'outdoor',
  CULTURAL: 'cultural',
  RECREATION: 'recreation',
  SCENIC: 'scenic',
  BEACH: 'beach',
  PLAYGROUND: 'playground',
  GROCERY: 'grocery',
  TRANSPORT: 'transport',
  OTHER: 'other',
} as const;

type ActivityType = (typeof ActivityType)[keyof typeof ActivityType];

// Keywords for inferring activity types from activity names
const ACTIVITY_TYPE_KEYWORDS: Record<ActivityType, string[]> = {
  [ActivityType.RESTAURANT]: [
    'restaurant',
    'cafe',
    'bar',
    'pub',
    'bistro',
    'brewery',
    'winery',
    'dining',
    'food',
    'meal',
    'breakfast',
    'lunch',
    'dinner',
    'eat',
    'drink',
    'coffee',
    'bakery',
    'deli',
    'pizzeria',
    'buffet',
    'kitchen',
    'grill',
    'tavern',
  ],
  [ActivityType.ATTRACTION]: [
    'museum',
    'gallery',
    'park',
    'garden',
    'zoo',
    'aquarium',
    'attraction',
    'monument',
    'landmark',
    'sightseeing',
    'tourist',
    'visit',
    'tour',
    'observatory',
    'heritage',
    'historic',
    'castle',
    'palace',
    'cathedral',
    'church',
    'temple',
    'bridge',
    'tower',
    'falls',
    'waterfall',
    'sound',
    'fiord',
    'milford',
    'head',
    'cape',
    'point',
  ],
  [ActivityType.SHOPPING]: [
    'shop',
    'shopping',
    'market visit',
    'store',
    'mall',
    'boutique',
    'outlet',
    'souvenir',
    'craft store',
    'artisan shop',
    'farmers market',
    'buy',
    'purchase',
    'retail',
    'shopping centre',
    'shopping plaza',
  ],
  [ActivityType.OUTDOOR]: [
    'hiking',
    'walk',
    'trail',
    'track',
    'climb',
    'climbing',
    'kayak',
    'rafting',
    'fishing',
    'swimming',
    'surf',
    'bike',
    'cycling',
    'mountain',
    'alpine',
    'glacier',
    'fjord',
    'adventure',
    'outdoor',
    'nature',
    'wildlife',
    'safari',
    'bungee',
    'skydive',
    'zip',
    'jetboat',
    'cruise',
    'sailing',
    'boat trip',
    'whale watching',
    'dolphin',
    'seal',
    'penguin',
    'bird watching',
  ],
  [ActivityType.CULTURAL]: [
    'cultural',
    'culture',
    'maori',
    'indigenous',
    'traditional',
    'performance',
    'show',
    'theatre',
    'concert',
    'festival',
    'event',
    'art exhibition',
    'music',
    'dance',
    'workshop',
    'cultural experience',
    'cultural village',
    'community',
    'hangi',
    'cultural centre',
  ],
  [ActivityType.TRANSPORT]: [
    'drive',
    'driving',
    'flight',
    'ferry',
    'bus',
    'train',
    'transfer',
    'pickup',
    'drop off',
    'rental',
    'car hire',
    'airport',
    'station',
    'terminal',
    'departure',
    'arrival',
    'journey',
    'travel',
    'scenic drive',
    'route',
    'highway',
    'road',
  ],
  [ActivityType.RECREATION]: [
    'springs',
    'hot pools',
    'gondola',
    'luge',
    'jet',
    'jetboat',
    'cruise',
    'farm tour',
    'animal experience',
    'wildlife',
    'glowworm',
    'caves',
    'puzzling',
    'maze',
  ],
  [ActivityType.SCENIC]: [
    'lookout',
    'viewpoint',
    'view point',
    'summit',
    'bridge walkway',
    'scenic reserve',
    'pass',
    'mirror',
    'lake views',
  ],
  [ActivityType.BEACH]: ['beach', 'pier', 'coastline', 'bay', 'foreshore'],
  [ActivityType.PLAYGROUND]: ['playground', 'play area', 'dinosaur park', 'family playground', 'lakefront playground'],
  [ActivityType.GROCERY]: ['woolworths', 'supermarket', 'grocery', 'food market'],
  [ActivityType.OTHER]: [],
};

/**
 * Infers activity type from Google Places API types
 */
function inferActivityTypeFromGooglePlaces(placeTypes: string[]): ActivityType {
  const googlePlaceTypeMap: Record<string, ActivityType> = {
    // Restaurant types
    restaurant: ActivityType.RESTAURANT,
    food: ActivityType.RESTAURANT,
    meal_takeaway: ActivityType.RESTAURANT,
    meal_delivery: ActivityType.RESTAURANT,
    cafe: ActivityType.RESTAURANT,
    bar: ActivityType.RESTAURANT,
    bakery: ActivityType.RESTAURANT,
    night_club: ActivityType.RESTAURANT,

    // Grocery types (more specific than general shopping)
    supermarket: ActivityType.GROCERY,
    grocery_or_supermarket: ActivityType.GROCERY,
    convenience_store: ActivityType.GROCERY,

    // Playground types
    playground: ActivityType.PLAYGROUND,

    // Beach types
    beach: ActivityType.BEACH,

    // Recreation types
    amusement_park: ActivityType.RECREATION,
    aquarium: ActivityType.RECREATION,
    zoo: ActivityType.RECREATION,
    spa: ActivityType.RECREATION,
    bowling_alley: ActivityType.RECREATION,

    // Scenic types (viewpoints and natural landmarks)
    natural_feature: ActivityType.SCENIC,
    point_of_interest: ActivityType.SCENIC,

    // Attraction types
    tourist_attraction: ActivityType.ATTRACTION,
    museum: ActivityType.ATTRACTION,
    art_gallery: ActivityType.ATTRACTION,
    park: ActivityType.ATTRACTION,
    landmark: ActivityType.ATTRACTION,

    // Shopping types
    shopping_mall: ActivityType.SHOPPING,
    store: ActivityType.SHOPPING,
    clothing_store: ActivityType.SHOPPING,
    shoe_store: ActivityType.SHOPPING,
    jewelry_store: ActivityType.SHOPPING,
    book_store: ActivityType.SHOPPING,
    electronics_store: ActivityType.SHOPPING,
    furniture_store: ActivityType.SHOPPING,
    department_store: ActivityType.SHOPPING,

    // Outdoor types
    campground: ActivityType.OUTDOOR,
    rv_park: ActivityType.OUTDOOR,
    stadium: ActivityType.OUTDOOR,
    gym: ActivityType.OUTDOOR,

    // Cultural types
    library: ActivityType.CULTURAL,
    university: ActivityType.CULTURAL,
    school: ActivityType.CULTURAL,
    church: ActivityType.CULTURAL,
    hindu_temple: ActivityType.CULTURAL,
    mosque: ActivityType.CULTURAL,
    synagogue: ActivityType.CULTURAL,
    place_of_worship: ActivityType.CULTURAL,

    // Transport types
    airport: ActivityType.TRANSPORT,
    bus_station: ActivityType.TRANSPORT,
    train_station: ActivityType.TRANSPORT,
    transit_station: ActivityType.TRANSPORT,
    car_rental: ActivityType.TRANSPORT,
  };

  // Check each place type and return the first match
  for (const placeType of placeTypes) {
    const activityType = googlePlaceTypeMap[placeType];
    if (activityType) {
      return activityType;
    }
  }

  return ActivityType.OTHER;
}

/**
 * Infers activity type from activity name using keyword matching
 */
function inferActivityType(activityName: string, existingType?: ActivityType, googlePlaceTypes?: string[]): ActivityType {
  // If activity already has a type, use it
  if (existingType && Object.values(ActivityType).includes(existingType)) {
    return existingType;
  }

  // If Google Places types are provided, use them for inference
  if (googlePlaceTypes && googlePlaceTypes.length > 0) {
    const inferredFromPlaces = inferActivityTypeFromGooglePlaces(googlePlaceTypes);
    if (inferredFromPlaces !== ActivityType.OTHER) {
      return inferredFromPlaces;
    }
  }

  // Convert activity name to lowercase for case-insensitive matching
  const nameToCheck = activityName.toLowerCase();

  // Check each activity type's keywords in priority order
  // Order matters: more specific types should be checked first
  const typeOrder = [
    ActivityType.GROCERY, // Very specific keywords
    ActivityType.PLAYGROUND, // Very specific keywords
    ActivityType.RESTAURANT, // Check before BEACH to avoid false matches on "wharf" etc
    ActivityType.BEACH, // Specific location type
    ActivityType.RECREATION, // Specific activity type
    ActivityType.SCENIC, // Specific viewpoint type
    ActivityType.SHOPPING,
    ActivityType.OUTDOOR,
    ActivityType.CULTURAL,
    ActivityType.TRANSPORT,
    ActivityType.ATTRACTION, // Last because it has generic words like "visit"
  ];

  for (const activityType of typeOrder) {
    const keywords = ACTIVITY_TYPE_KEYWORDS[activityType];
    for (const keyword of keywords) {
      if (nameToCheck.includes(keyword.toLowerCase())) {
        return activityType;
      }
    }
  }

  return ActivityType.OTHER;
}

// Rate limiting configuration
const RATE_LIMIT_MS = 200; // 200ms between API calls
const MAX_RETRIES = 3;

interface PlaceSearchResult {
  place_id?: string;
  photo_url?: string;
  name?: string;
  types?: string[];
}

interface EnrichmentStats {
  total: number;
  enriched: number;
  skipped: number;
  failed: number;
  details: {
    accommodations: { total: number; enriched: number };
    activities: { total: number; enriched: number; typesEnriched: number };
    waypoints: { total: number; enriched: number };
  };
}

/**
 * Load environment variables from .env.local for Node.js scripts
 */
async function loadEnvFile(envPath: string): Promise<void> {
  try {
    const content = await fs.readFile(envPath, 'utf-8');
    for (const line of content.split('\n')) {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith('#')) {
        const [key, ...valueParts] = trimmed.split('=');
        const value = valueParts.join('=').replace(/^["']|["']$/g, '');
        if (key && !process.env[key]) {
          process.env[key] = value;
        }
      }
    }
  } catch {
    // .env.local might not exist
  }
}

/**
 * Validate required environment variables
 */
function validateEnvConfig(): void {
  const googleMapsKey = process.env.GOOGLE_PLACES_API_KEY || process.env.VITE_GOOGLE_MAPS_API_KEY || process.env.GOOGLE_MAPS_API_KEY;
  if (googleMapsKey) {
    const keySource = process.env.GOOGLE_PLACES_API_KEY
      ? 'GOOGLE_PLACES_API_KEY'
      : process.env.VITE_GOOGLE_MAPS_API_KEY
        ? 'VITE_GOOGLE_MAPS_API_KEY'
        : 'GOOGLE_MAPS_API_KEY';
    console.log(`‚úì Using API key from: ${keySource}`);
    if (keySource.startsWith('VITE_')) {
      console.warn('  Note: VITE_ keys may have HTTP referrer restrictions.');
      console.warn('  For server-side access, create a key with IP restrictions.\n');
    }
  } else {
    console.warn('‚ö†Ô∏è  No Google Maps API key found. Will use og:image and Wikipedia fallbacks only.');
    console.warn('   For Google Places photos, set GOOGLE_PLACES_API_KEY with IP restrictions.\n');
  }

  const requiredFirebaseVars = ['VITE_FIREBASE_API_KEY', 'VITE_FIREBASE_PROJECT_ID'];
  const missingFirebase = requiredFirebaseVars.filter((v) => !process.env[v]);
  if (missingFirebase.length > 0) {
    console.warn('‚ö†Ô∏è  Missing Firebase config, will only update local file:', missingFirebase.join(', '));
  }
}

/**
 * Sleep for rate limiting
 */
function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Get Google Maps API key from environment
 * Priority: GOOGLE_PLACES_API_KEY > VITE_GOOGLE_MAPS_API_KEY > GOOGLE_MAPS_API_KEY
 */
function getGoogleMapsApiKey(): string {
  return process.env.GOOGLE_PLACES_API_KEY || process.env.VITE_GOOGLE_MAPS_API_KEY || process.env.GOOGLE_MAPS_API_KEY || '';
}

/**
 * Search for a place using Google Places Text Search API (Legacy)
 * https://developers.google.com/maps/documentation/places/web-service/search-text
 *
 * Note: Using legacy API as it supports server-side requests without HTTP referrer
 */
async function searchPlaceByText(query: string, location?: { lat: number; lng: number }): Promise<PlaceSearchResult | null> {
  const apiKey = getGoogleMapsApiKey();

  // Build URL for legacy Text Search API
  const params = new URLSearchParams({
    query,
    key: apiKey,
  });

  // Add location bias if coordinates are provided
  if (location && location.lat && location.lng) {
    params.set('location', `${location.lat},${location.lng}`);
    params.set('radius', '5000'); // 5km radius
  }

  const endpoint = `https://maps.googleapis.com/maps/api/place/textsearch/json?${params}`;

  for (let retry = 0; retry < MAX_RETRIES; retry++) {
    try {
      const response = await fetch(endpoint);

      if (response.status === 429) {
        // Rate limited, wait and retry
        await sleep(1000 * (retry + 1));
        continue;
      }

      if (!response.ok) {
        const errorText = await response.text();
        console.error(`  ‚ö†Ô∏è Places API error: ${response.status} - ${errorText}`);
        return null;
      }

      const data = await response.json();

      if (data.status === 'ZERO_RESULTS' || !data.results || data.results.length === 0) {
        return null;
      }

      if (data.status !== 'OK') {
        console.error(`  ‚ö†Ô∏è Places API status: ${data.status} - ${data.error_message || ''}`);
        return null;
      }

      const place = data.results[0];
      let photoUrl: string | undefined;

      // Get photo URL if available
      if (place.photos && place.photos.length > 0) {
        const photoRef = place.photos[0].photo_reference;
        // Use Places Photo API to get the photo URL
        photoUrl = `https://maps.googleapis.com/maps/api/place/photo?maxwidth=400&photo_reference=${photoRef}&key=${apiKey}`;
      }

      return {
        place_id: place.place_id,
        photo_url: photoUrl,
        name: place.name,
        types: place.types || [],
        types: place.types || [],
      };
    } catch (error) {
      console.error('  ‚ö†Ô∏è Places API request failed:', error);
      if (retry < MAX_RETRIES - 1) {
        await sleep(500 * (retry + 1));
      }
    }
  }

  return null;
}

/**
 * Try to extract og:image from a website URL
 */
async function fetchOgImageFromUrl(url: string): Promise<string | null> {
  if (!url) return null;

  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 5000);

    const response = await fetch(url, {
      signal: controller.signal,
      headers: {
        'User-Agent': 'Mozilla/5.0 (compatible; Wanderlog/1.0)',
      },
    });

    clearTimeout(timeout);

    if (!response.ok) return null;

    const html = await response.text();

    // Extract og:image meta tag
    const ogImageMatch = html.match(/<meta[^>]+property=["']og:image["'][^>]+content=["']([^"']+)["']/i);
    if (ogImageMatch?.[1]) {
      return ogImageMatch[1];
    }

    // Try twitter:image as fallback
    const twitterImageMatch = html.match(/<meta[^>]+name=["']twitter:image["'][^>]+content=["']([^"']+)["']/i);
    if (twitterImageMatch?.[1]) {
      return twitterImageMatch[1];
    }

    return null;
  } catch {
    return null;
  }
}

/**
 * Try to get an image from alternative sources
 */
async function searchImageByAlternativeSources(placeName: string, location?: string, url?: string): Promise<string | null> {
  // Try DOC.govt.nz API for NZ places
  if (url?.includes('doc.govt.nz')) {
    const docImage = await fetchOgImageFromUrl(url);
    if (docImage) return docImage;
  }

  // Try to construct a Wikipedia URL for famous places
  const wikiSearchTerms = [placeName, `${placeName} New Zealand`, location ? `${placeName} ${location}` : null].filter(Boolean);

  for (const term of wikiSearchTerms) {
    try {
      const wikiUrl = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(term as string)}`;
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 5000);

      const response = await fetch(wikiUrl, {
        signal: controller.signal,
        headers: { 'User-Agent': 'Wanderlog/1.0' },
      });

      clearTimeout(timeout);

      if (response.ok) {
        const data = await response.json();
        if (data.thumbnail?.source) {
          return data.thumbnail.source;
        }
      }
    } catch {
      // Continue to next source
    }
  }

  return null;
}

/**
 * Enrich a single place with thumbnail_url, google_place_id, and activity_type (for activities)
 * Enrich a single place with thumbnail_url, google_place_id, and activity_type (for activities)
 */
async function enrichPlace(
  name: string,
  existingThumbnail: string | null | undefined,
  existingPlaceId: string | null | undefined,
  existingActivityType: ActivityType | null | undefined,
  existingActivityType: ActivityType | null | undefined,
  location?: { lat?: number; lng?: number; address?: string },
  url?: string
): Promise<{
  thumbnail_url: string | null;
  google_place_id: string | null;
  activity_type: ActivityType | null;
  changed: boolean;
  typeChanged: boolean;
}> {
): Promise<
  thumbnail_url: string | null;
  google_place_id: string | null;
  activity_type: ActivityType | null;
  changed: boolean;
  typeChanged: boolean;> {
  let thumbnail_url = existingThumbnail || null;
  let google_place_id = existingPlaceId || null;
  let activity_type = existingActivityType || null;
  let activity_type = existingActivityType || null;
  let changed = false;
  let typeChanged = false;
  let placeTypes: string[] = [];
  let typeChanged = false;
  let placeTypes: string[] = [];

  // Try Google Places API first
  if (!(thumbnail_url && google_place_id)) {
    const searchQuery = location?.address ? `${name} ${location.address}` : name;
    const coords = location?.lat && location?.lng ? { lat: location.lat, lng: location.lng } : undefined;

    await sleep(RATE_LIMIT_MS);
    const placeResult = await searchPlaceByText(searchQuery, coords);

    if (placeResult) {
      if (!google_place_id && placeResult.place_id) {
        google_place_id = placeResult.place_id;
        changed = true;
      }
      if (!thumbnail_url && placeResult.photo_url) {
        thumbnail_url = placeResult.photo_url;
        changed = true;
      }
      if (placeResult.types && placeResult.types.length > 0) {
        placeTypes = placeResult.types;
      }
    }
  }

  // Infer activity type if not already set
  if (!activity_type && existingActivityType === undefined) {
    const inferredType = inferActivityType(name, undefined, placeTypes.length > 0 ? placeTypes : undefined);
    if (inferredType && inferredType !== 'other') {
      activity_type = inferredType as ActivityType;
      typeChanged = true;
      if (placeResult.types && placeResult.types.length > 0) {
        placeTypes = placeResult.types;
      }
    }
  }

  // Infer activity type if not already set
  if (!activity_type && existingActivityType === undefined) {
    const inferredType = inferActivityType(name, undefined, placeTypes.length > 0 ? placeTypes : undefined);
    if (inferredType && inferredType !== 'other') {
      activity_type = inferredType as ActivityType;
      typeChanged = true;
    }
  }

  // Try fetching og:image from the place URL
  if (!thumbnail_url && url) {
    const ogImage = await fetchOgImageFromUrl(url);
    if (ogImage) {
      thumbnail_url = ogImage;
      changed = true;
    }
  }

  // Try alternative sources (Wikipedia, etc.)
  if (!thumbnail_url) {
    const altImage = await searchImageByAlternativeSources(name, location?.address, url);
    if (altImage) {
      thumbnail_url = altImage;
      changed = true;
    }
  }

  return { thumbnail_url, google_place_id, activity_type, changed, typeChanged };
}

/**
 * Enrich accommodation data
 */
async function enrichAccommodation(accommodation: Accommodation): Promise<{ accommodation: Accommodation; enriched: boolean }> {
  if (!(accommodation && accommodation.name)) {
    return { accommodation, enriched: false };
  }

  console.log(`  üìç Accommodation: ${accommodation.name}`);

  const result = await enrichPlace(
    accommodation.name,
    accommodation.thumbnail_url,
    accommodation.google_place_id,
    undefined, // accommodations don't have activity_type
    undefined, // accommodations don't have activity_type
    accommodation.location ? { ...accommodation.location, address: accommodation.address } : { address: accommodation.address },
    accommodation.url
  );

  if (result.changed) {
    console.log(`     ‚úÖ Enriched (thumbnail: ${result.thumbnail_url ? 'yes' : 'no'}, place_id: ${result.google_place_id ? 'yes' : 'no'})`);
    return {
      accommodation: {
        ...accommodation,
        thumbnail_url: result.thumbnail_url ?? undefined,
        google_place_id: result.google_place_id ?? undefined,
      },
      enriched: true,
    };
  }

  console.log('     ‚è≠Ô∏è  Skipped (already has data or no results)');
  return { accommodation, enriched: false };
}

/**
 * Enrich activity data
 */
async function enrichActivity(activity: Activity): Promise<{ activity: Activity; enriched: boolean; typeEnriched: boolean }> {
async function enrichActivity(activity: Activity): Promise<{ activity: Activity; enriched: boolean; typeEnriched: boolean }> {
  if (!(activity && activity.activity_name)) {
    return { activity, enriched: false, typeEnriched: false };
    return { activity, enriched: false, typeEnriched: false };
  }

  console.log(`  üìç Activity: ${activity.activity_name}`);

  const result = await enrichPlace(
    activity.activity_name,
    activity.thumbnail_url,
    activity.google_place_id,
    activity.activity_type,
    activity.activity_type,
    activity.location,
    activity.url
  );

  const anyChange = result.changed || result.typeChanged;

  if (anyChange) {
    const changes: string[] = [];
    if (result.thumbnail_url) changes.push('thumbnail');
    if (result.google_place_id) changes.push('place_id');
    if (result.typeChanged && result.activity_type) changes.push(`type:${result.activity_type}`);

    console.log(`     ‚úÖ Enriched (${changes.join(', ')})`);
  const anyChange = result.changed || result.typeChanged;

  if (anyChange) {
    const changes: string[] = [];
    if (result.thumbnail_url) changes.push('thumbnail');
    if (result.google_place_id) changes.push('place_id');
    if (result.typeChanged && result.activity_type) changes.push(`type:${result.activity_type}`);

    console.log(`     ‚úÖ Enriched (${changes.join(', ')})`);
    return {
      activity: {
        ...activity,
        thumbnail_url: result.thumbnail_url ?? activity.thumbnail_url,
        google_place_id: result.google_place_id ?? activity.google_place_id,
        activity_type: result.activity_type ?? activity.activity_type,
        thumbnail_url: result.thumbnail_url ?? activity.thumbnail_url,
        google_place_id: result.google_place_id ?? activity.google_place_id,
        activity_type: result.activity_type ?? activity.activity_type,
      },
      enriched: result.changed,
      typeEnriched: result.typeChanged,
      enriched: result.changed,
      typeEnriched: result.typeChanged,
    };
  }

  if (activity.activity_type) {
    console.log(`     ‚è≠Ô∏è  Skipped (type: ${activity.activity_type})`);
  } else {
    console.log('     ‚è≠Ô∏è  Skipped (already has data or no results)');
  }
  return { activity, enriched: false, typeEnriched: false };
  if (activity.activity_type) {
    console.log(`     ‚è≠Ô∏è  Skipped (type: ${activity.activity_type})`);
  } else {
    console.log('     ‚è≠Ô∏è  Skipped (already has data or no results)');
  }
  return { activity, enriched: false, typeEnriched: false };
}

/**
 * Enrich scenic waypoint data
 */
async function enrichWaypoint(waypoint: ScenicWaypoint): Promise<{ waypoint: ScenicWaypoint; enriched: boolean }> {
  if (!(waypoint && waypoint.activity_name)) {
    return { waypoint, enriched: false };
  }

  console.log(`  üìç Waypoint: ${waypoint.activity_name}`);

  const result = await enrichPlace(
    waypoint.activity_name,
    waypoint.thumbnail_url,
    waypoint.google_place_id,
    undefined, // waypoints don't have activity_type
    undefined, // waypoints don't have activity_type
    waypoint.location,
    waypoint.url
  );

  if (result.changed) {
    console.log(`     ‚úÖ Enriched (thumbnail: ${result.thumbnail_url ? 'yes' : 'no'}, place_id: ${result.google_place_id ? 'yes' : 'no'})`);
    return {
      waypoint: {
        ...waypoint,
        thumbnail_url: result.thumbnail_url ?? undefined,
        google_place_id: result.google_place_id ?? undefined,
      },
      enriched: true,
    };
  }

  console.log('     ‚è≠Ô∏è  Skipped (already has data or no results)');
  return { waypoint, enriched: false };
}

/**
 * Read and parse a trip data JSON file
 */
async function readTripDataFile(filename: string): Promise<{ tripData: TripData; rawData: unknown }> {
  const tripDataDir = path.join(__dirname, '../local/trip-data');
  const filePath = path.join(tripDataDir, filename);

  console.log(`Reading ${filename}...`);
  const fileContent = await fs.readFile(filePath, 'utf-8');
  const rawData = JSON.parse(fileContent);

  // Handle both wrapped and unwrapped formats
  const tripData = rawData.tripData || rawData;

  if (!(tripData.trip_name && tripData.timezone && Array.isArray(tripData.stops))) {
    throw new Error('Invalid trip data format');
  }

  return { tripData: tripData as TripData, rawData };
}

/**
 * Write trip data back to JSON file
 */
async function writeTripDataFile(filename: string, rawData: unknown, tripData: TripData): Promise<void> {
  const tripDataDir = path.join(__dirname, '../local/trip-data');
  const filePath = path.join(tripDataDir, filename);

  // Preserve the original structure (wrapped or unwrapped)
  let dataToWrite: unknown;
  if (typeof rawData === 'object' && rawData !== null && 'tripData' in rawData) {
    dataToWrite = { ...rawData, tripData };
  } else {
    dataToWrite = tripData;
  }

  await fs.writeFile(filePath, JSON.stringify(dataToWrite, null, 2) + '\n', 'utf-8');
  console.log(`‚úÖ Updated ${filename}`);
}

/**
 * Generate trip ID from filename
 */
function generateTripId(filename: string): string {
  return filename.replace(/_trip-plan\.json$/, '');
}

/**
 * Get all trip data files
 */
async function getAllTripDataFiles(): Promise<string[]> {
  const tripDataDir = path.join(__dirname, '../local/trip-data');
  const files = await fs.readdir(tripDataDir);
  return files.filter((file) => file.endsWith('_trip-plan.json'));
}

/**
 * Main enrichment function for a single trip
 */
async function enrichTripData(filename: string): Promise<EnrichmentStats> {
  const stats: EnrichmentStats = {
    total: 0,
    enriched: 0,
    skipped: 0,
    failed: 0,
    details: {
      accommodations: { total: 0, enriched: 0 },
      activities: { total: 0, enriched: 0, typesEnriched: 0 },
      activities: { total: 0, enriched: 0, typesEnriched: 0 },
      waypoints: { total: 0, enriched: 0 },
    },
  };

  const { tripData, rawData } = await readTripDataFile(filename);
  const tripId = generateTripId(filename);

  console.log(`\nüåç Enriching trip: ${tripData.trip_name} (${tripId})`);
  console.log(`   Stops: ${tripData.stops.length}\n`);

  // Process each stop
  for (const stop of tripData.stops) {
    console.log(`\nüìå Stop: ${stop.name}`);

    // Enrich accommodation
    if (stop.accommodation && stop.accommodation.name) {
      stats.total++;
      stats.details.accommodations.total++;
      const { accommodation, enriched } = await enrichAccommodation(stop.accommodation);
      const { accommodation, enriched } = await enrichAccommodation(stop.accommodation);
      stop.accommodation = accommodation;
      if (enriched) {
        stats.enriched++;
        stats.details.accommodations.enriched++;
      } else {
        stats.skipped++;
      }
    }

    // Enrich activities
    if (stop.activities && Array.isArray(stop.activities)) {
      for (let i = 0; i < stop.activities.length; i++) {
        stats.total++;
        stats.details.activities.total++;
        const { activity, enriched, typeEnriched } = await enrichActivity(stop.activities[i]);
        const { activity, enriched, typeEnriched } = await enrichActivity(stop.activities[i]);
        stop.activities[i] = activity;
        if (enriched) {
          stats.enriched++;
          stats.details.activities.enriched++;
        }
        if (typeEnriched) {
          stats.details.activities.typesEnriched++;
        }
        if (!(enriched || typeEnriched)) {
          stats.skipped++;
        }
      }
    }

    // Enrich scenic waypoints
    if (stop.scenic_waypoints && Array.isArray(stop.scenic_waypoints)) {
      for (let i = 0; i < stop.scenic_waypoints.length; i++) {
        stats.total++;
        stats.details.waypoints.total++;
        const { waypoint, enriched } = await enrichWaypoint(stop.scenic_waypoints[i]);
        stop.scenic_waypoints[i] = waypoint;
        if (enriched) {
          stats.enriched++;
          stats.details.waypoints.enriched++;
        } else {
          stats.skipped++;
        }
      }
    }
  }

  // Write updated data to JSON file
  await writeTripDataFile(filename, rawData, tripData);

  // Update Firebase if configured
  const hasFirebaseConfig = process.env.VITE_FIREBASE_API_KEY && process.env.VITE_FIREBASE_PROJECT_ID;
  if (hasFirebaseConfig) {
    try {
      const firebaseConfig = await import('../src/config/firebase.js');
      const firebaseService = await import('../src/services/firebaseService.js');

      firebaseConfig.initializeFirebase();
      await firebaseService.updateTrip(tripId, { stops: tripData.stops });
      console.log(`‚úÖ Updated Firebase: ${tripId}`);
    } catch (error) {
      console.error('‚ö†Ô∏è  Failed to update Firebase:', error);
    }
  } else {
    console.log('‚ö†Ô∏è  Firebase not configured, skipping cloud update');
  }

  return stats;
}

/**
 * Main function
 */
async function main(): Promise<void> {
  console.log('üöÄ Wanderlog Trip Data Enrichment Tool\n');
  console.log('This script enriches trip data with:');
  console.log('  - thumbnail_url: Images for places');
  console.log('  - google_place_id: Google Places IDs\n');
  console.log('Image source priority:');
  console.log('  1. Existing thumbnail_url (skip if already set)');
  console.log('  2. Google Places API photo');
  console.log('  3. og:image from place URL');
  console.log('  4. Web search by place name\n');

  // Load environment variables
  await loadEnvFile(path.join(__dirname, '../.env.local'));
  validateEnvConfig();

  // Parse command line arguments
  const args = process.argv.slice(2);
  const filenames = args.filter((arg) => !arg.startsWith('--'));

  try {
    let totalStats: EnrichmentStats = {
      total: 0,
      enriched: 0,
      skipped: 0,
      failed: 0,
      details: {
        accommodations: { total: 0, enriched: 0 },
        activities: { total: 0, enriched: 0, typesEnriched: 0 },
        activities: { total: 0, enriched: 0, typesEnriched: 0 },
        waypoints: { total: 0, enriched: 0 },
      },
    };

    if (filenames.length === 0) {
      // Enrich all trips
      console.log('No specific file specified. Enriching all trips...\n');
      const allFiles = await getAllTripDataFiles();

      if (allFiles.length === 0) {
        console.log('No trip data files found in local/trip-data/');
        return;
      }

      console.log(`Found ${allFiles.length} trip(s) to enrich:\n`);

      for (const filename of allFiles) {
        const stats = await enrichTripData(filename);
        totalStats.total += stats.total;
        totalStats.enriched += stats.enriched;
        totalStats.skipped += stats.skipped;
        totalStats.failed += stats.failed;
        totalStats.details.accommodations.total += stats.details.accommodations.total;
        totalStats.details.accommodations.enriched += stats.details.accommodations.enriched;
        totalStats.details.activities.total += stats.details.activities.total;
        totalStats.details.activities.enriched += stats.details.activities.enriched;
        totalStats.details.activities.typesEnriched += stats.details.activities.typesEnriched;
        totalStats.details.activities.typesEnriched += stats.details.activities.typesEnriched;
        totalStats.details.waypoints.total += stats.details.waypoints.total;
        totalStats.details.waypoints.enriched += stats.details.waypoints.enriched;
      }
    } else {
      // Enrich specific trips
      for (const filename of filenames) {
        const stats = await enrichTripData(filename);
        totalStats = stats;
      }
    }

    // Print summary
    console.log('\n' + '='.repeat(60));
    console.log('üìä Enrichment Summary');
    console.log('='.repeat(60));
    console.log(`Total places processed: ${totalStats.total}`);
    console.log(`  - Enriched: ${totalStats.enriched}`);
    console.log(`  - Skipped: ${totalStats.skipped}`);
    console.log(`  - Failed: ${totalStats.failed}`);
    console.log('\nBy category:');
    console.log(`  - Accommodations: ${totalStats.details.accommodations.enriched}/${totalStats.details.accommodations.total}`);
    console.log(
      `  - Activities: ${totalStats.details.activities.enriched}/${totalStats.details.activities.total} (types: ${totalStats.details.activities.typesEnriched})`
    );
    console.log(`  - Waypoints: ${totalStats.details.waypoints.enriched}/${totalStats.details.waypoints.total}`);
    console.log('\n‚úÖ Enrichment completed!');
  } catch (error) {
    console.error('\n‚ùå Enrichment failed:', error);
    process.exit(1);
  }
}

// Run the enrichment
main().catch((error) => {
  console.error('Unhandled error:', error);
  process.exit(1);
});
